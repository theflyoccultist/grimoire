## Why Ruby? Because I Had Enough of JavaScript.

I originally picked up Ruby out of **pure JavaScript fatigue**—I was tired of maintaining a monstrous Express + React project. It was easier to burn everything down and start fresh with a new language than continue suffering.

That turned out to be **one of my best decisions**. By switching to Ruby’s Sinatra framework, I replaced 5000 lines of bloated code with **a single backend file** and some clean HTML templates. Alongside Python, Ruby will continue to be my go-to for **small web projects**—whether that’s to avoid paying monthly for some overhyped SaaS tool or simply to reclaim time lost to unnecessarily complicated frameworks.

Ruby projects are also **ridiculously easy to deploy**, making it perfect for **my DevOps journey**—because what’s the point of studying infrastructure if I’m not constantly deploying things?

Coming from my C studies, Ruby feels like a different world—**full of abstractions, letting you get away with absurdly concise one-liners.** Debugging is a **breeze**, and for scripting and automation, it offers an interesting alternative to Python.

I had **zero prior experience** when I first picked it up, but that didn’t stop me from shipping projects with it. In this section of the grimoire, **we’ll be discovering Ruby’s true power together**—because it turns out, this language has more depth than it first appears.
